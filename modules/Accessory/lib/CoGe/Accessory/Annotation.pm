package CoGe::Accessory::Annotation;
use strict;
use base qw(Class::Accessor) ;
use Data::Dumper ;

BEGIN {
    use Exporter ();
    use vars qw ($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $AUTOLOAD);
    $VERSION     = 0.1;
    @ISA         = qw (Exporter Class::Accessor );
    #Give a hoot don't pollute, do not export more than needed by default
    @EXPORT      = qw ();
    @EXPORT_OK   = qw ();
    %EXPORT_TAGS = ();
    __PACKAGE__->mk_accessors('Type', 'Values', 'Search_term',
    	'Val_delimit', 'Type_delimit', '_index', 'Add_type', 'String_end');
}

=head2 new

 Usage    :  my $annot = new  Annotation(Type=>"",Values=>"").
 Purpose  :  creates an instance of the
             Annotation object. This object
             has 2 attributes,Type and
             Values.The Type attribute
             of the object is set to
             the value the user inputs.
             If there's no user input ,
             a default value 'unknown'
             is used.  The Values attribute
             is initialized to an empty
             array. Besides Type, if there
             are additional args that are
             passed in, they are collected
             into the values array.The user
             can pass a string, array or ref
             to an array as values to the
             Values attribute. The Values
             attribute is set by calling
             the add_Annot method on every
             element of the values array.
             add_Annot method is also called
             to condense objects of same
             type into a single object.
 Argument : The user can give args Type and
            Values or either of them, but the
            should always have the key 'Type'
            or 'Values'.

=cut

sub new {
    my ($class,%params) = @_ ;
    my $self = bless ({}, ref ($class) || $class);
    my @arr = () ;
    my $type = $params{'Type'} || $params{'T'} || 'unknown' ;
    my $vals = $params{'Values'} || $params{'V'} || \@arr  ;
    $self->{Val_delimit} = $params{'Val_delimit'} || '-' ;
    $self->{Type_delimit} = $params{'Type_delimit'} || '-' ;
    $self->{Add_type} = $params{'Add_type'} || '1' ; #flag for whether or not the type is added in the to_String() function
    $self->{String_end} = $params{'String_end'} || '' ; #item to add to the end of an annotation string when generated by to_String()
    $self->{Type} = $type ;
    $self->{Values} = [] ;
    my @val_arr = ref($vals) =~ /ARRAY/ ? @$vals : $vals ;
    foreach (@val_arr){
      $self->add_Annot($_) ;
    }
    ## index to keep track of the position
    #in the values array.
    $self->{_index} = 0 ;
    return $self ;
}

=head2 add_Annot

 Usage     :   $annot->add_Annot($args) ;
 Purpose   :   This method is meant to add
               values to the Values attribute,
               In the first step, collects
               all the args that have been
               passed into an array, if any
               of the args is an array ref,
               it is dereferenced and the
               array is stored.

               Each of these args is checked
               for its data type; If it is an
               Annotation object, a check is
               performed to see if any of the
               values already existing in the
               Values attribute of the main
               objects are also objects of the
               same Type as the Type of the
               object being added, if true,
               it then just appends the values
               of the arg object to the Values
               attribute of the main object.
               If not true, it then adds
               an additional element to the
               Values attribute array of the
               main object.

               If the value being added is
               not an Annotation object, then
               it gets pushed into the Values
               attribute array.
 Argument  :   can be an array, ref to an array, another
               Annotation object or a string.

=cut

sub add_Annot {
  my $self = shift ;
  my @vals ;
  foreach my $val(@_){
    push @vals,ref($val) =~ /ARRAY/ ? @$val : $val ;
  }
  foreach my $val(@vals){
      if(ref($val) =~ /Annotation/){
        if($self->has_a($val->Type())){
           my @sim_type = $self->get_by_type($val->Type());
           foreach my $sim_obj(@sim_type){
            $sim_obj->add_Annot($val->Values());
          }
        } else {
          push(@{$self->Values()},$val) ;
        }
      }else {
        push(@{$self->Values()},$val) ;
      }
    }
  }

=head2 to_String

 Usage     :  my $str = $annot->to_String('&') ;
 Purpose   :  Returns the elements in the Values array as
              a single string,the Values array can contain
              other Annotation objects, string variables
              or another array as its elements.The
              function first checks for the data type
              of each element.If the element is another
              Annotation object, the function is called
              recursively on the nested Annotation object.

              Else, if the element is an ARRAY,
              each element of this internal array
              is again checked for its data type, if
              again an Annotation object is present,
              same as above.If the internal element is
              an array, Perl's join() is used to concat
              the elements of the internal array into a
              string.If the elements are string variables
              themselves,they are concated to the main
              string variable that is being returned.
              Else, if the element is a HASH,the key
              value pairs of each entry are joined into a
              string and concated to the main string being
              returned.  Else, if the element is a string
              itself, it is joined to the main string
              thats returned.  Every elemnt is separated
              by inserting a deliomiter in between.

 Argument  : A delimiter(optional)

=cut

sub to_String {
  my $self = shift ;
  my $str;
  #for each of the elements in the Values
  #array, check the data type of each
  #element.
  $str .= $self->Type. $self->Type_delimit if $self->Add_type;

  foreach my $item(@{$self->Values()})
    {
      #if the element is an annotation
      #object, call the to_String() method on
      #the object;
      if(ref($item) =~ /Annotation/)
	{
	  $str .= $item->to_String();
	  }
      else
	{
          $str .= $item if $item;
        }
      ## Attach a delimiter between every
      #element.
      unless($str eq "")
	{
	  $str .= $self->Val_delimit;
        }
    }
  #remove trailing delimiter
  #characters
  my $vd = $self->Val_delimit;
  $str =~ s/$vd+$//g;
  $str .= $self->String_end if $self->String_end;
  return $str ;
}

=head2 has_a

 Usage     :  my $bool = $annot->has_a($search_term);
 Purpose   :  Return true if the the Values of the
              annotation object contains other annotation
              object(s) of type equal to the search term,
              else returns false.
 Returns   :  a boolean.
 Argument  :  Requires the search term

=cut

sub has_a {
  my $self = shift ;
  my $search = shift ;
  #print STDERR Dumper("SELF",$self->Values(),$self->Type(),ref($self)) ;
  foreach my $item(@{$self->Values()}){
    if(ref($item) ne ""){
    if(ref($item) =~ /Annotation/ || ref($item)->isa("Annotation")){
      if($item->Type() eq $search){
        return 1 ;
      } else {
        return 1 if($item->has_a($search)) ;
      }
    }
    }
  }
}

=head2 is_a

 Usage     : $annot->is_a($search_term) ;
 Purpose   : Checks if the given search term equal to
             the Type attribute of the annotation object
             that the method is called on.
 Returns   : a boolean.
 Argument  : Requires the search term

=cut

sub is_a {
  my $self = shift ;
  my $search_term = shift ;
  $self->Type() =~ /$search_term/ ? return 1 : return 0 ;
}

=head2 get_by_type

 Usage     :  my $type_object = $annot->get_by_type('searchterm');
              OR  my @type_Arr = $annot->get_by_type('searchterm');
 Purpose   :  If the Values attribute of
              the annotation object contains
              another annotation object(s)
              of the type equal to the
              search term, it is pushed into
              the return array.The array
              is returned.
 Returns   :  An array( OR its reference) of Annotation
              objects whose Type attribute is same as
              the search term entered by the user.
 Argument  :  search type

=cut

sub get_by_type{
  my $self = shift;
  my $search = shift;
  #escape terms in search
  my $esc_search = $search;
  $esc_search =~ s/\(/\\\(/g;
  $esc_search =~ s/\)/\\\)/g;
  $esc_search =~ s/\[/\\\]/g;
  $esc_search =~ s/\[/\\\]/g;
  my @arr ;
  foreach my $item(@{$self->Values()}){
    if(ref($item) =~ /Annotation/){
      if($item->Type() =~ /$esc_search/){
        push(@arr,$item) ;
      }
      if($item->has_a($search)){
        push(@arr,$item->get_by_type($search)) ;
      }
    }
  }
  wantarray ? return @arr : return \@arr ;
}

=head2 next

 Usage     : while(my $next = $annot->next()){ .... }
 Purpose   : Returns each of the elements of the Values
             attribute array, if an element in the array
             is not an Annotation object, it creates
             an Annotation object of Type=>unknown and
             the Values attribute of the newly created
             object will be assigned the value of the
             element in the array.
 Returns  :  Each element in the Values attribute as an
             Annotation Object

=cut

sub next {
  my $self = shift ;
  my $next = @{$self->Values()}[$self->_index()] ;
  $self->{_index}++ ;
  if(ref($next) ne 'Annotation' && defined $next){
    my $new = Annotation->new('Values'=>$next);
    return $new ;
  } else {
   return $next ;
  }
}

=head2 count

 Usage     : my $count = $annot->count() ;
 Purpose   : returns the number of elements in the
             Values attribute array
 Returns   : a number
 Argument  : none

=cut

sub count {
  my $self = shift ;
  if(defined $self->Values()){
    return scalar(@{$self->Values()}) ;
  } else {
    return 0 ;
  }
}

=head2 DESTROY

 Usage     :
 Purpose   :
 Returns   :
 Argument  :

=cut

sub DESTROY {
  my $self = shift ;
  return ;
}

1;

=head1 NAME

Annotation - Annotation

=head1 SYNOPSIS

  use Annotation

=head1 DESCRIPTION

=head1 USAGE

=head1 BUGS

=head1 SUPPORT

=head1 AUTHOR

	Eric Lyons

=head1 COPYRIGHT

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the
LICENSE file included with this module.

=head1 SEE ALSO

=cut
