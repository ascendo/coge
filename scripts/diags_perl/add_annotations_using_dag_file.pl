#!/usr/bin/perl -w
use strict;
use CoGeX;
use Getopt::Long;

use vars qw($DEBUG $file $coge $GO $source @skip_names);

GetOptions(
	   "file|f=s"=>\$file,
	   "debug"=>\$DEBUG,
	   "go"=>\$GO,
	   "source=i"=>\$source,
	   "skip_name=s"=>\@skip_names,
	   );
my $connstr = 'dbi:mysql:dbname=coge;host=HOST;port=PORT';
$coge = CoGeX->connect($connstr, 'USER', 'PASSWORD' );

unless (-r $file)
  {
    print qq{
Usage:  $0 <dag chainer aligncoords file> -go

OPTIONS:

 -f   dag chainer aligncoords file (usually generated by SynMap)

 -go     set to actually add data to database (DEFAULT undefined)

 -debug  debugging messages (DEFAULT undefined)

 -source  set to 1 or 2 to specify if the first or second feature in each column is the source
         for annotations.  The source feature's annotations will be copied to the other
         feature (the sink feature).  (DEFAULT 0.  This means that there is no default
         source specified an an error will be thrown.)

 -skip_name  set this to some string and it will be used in a regex /^skip_name/
             to skip a type of feature names.  For example /^NP/ and /^YP/ are
             skipped by default.  Add as many as you like by:
               -skip_name name1 -skip_name name2
};
    exit;
  }
$source = 0 unless $source;
print "NO SOURCE SPECIFIED!  No annotation mappings will happen.\n" unless $source;
print "go option is set to 0.  No annotation mappings will happen.\n" unless $GO;
open (IN, $file);
while (<IN>)
  {
    chomp;
    next unless $_;
    next if /^#/;
    my (@line) = split /\t/;
    my (@seq1) = split/\|\|/, $line[1];
    my (@seq2) = split/\|\|/, $line[5];
    my ($dsgid1, $chr1) = $line[0] =~/a(\d+)_(.+)/;
    my ($dsgid2, $chr2) = $line[4] =~/a(\d+)_(.+)/;
    my ($fid1) = $seq1[6];
    my ($fid2) = $seq2[6];
    my $feat1 = $coge->resultset('Feature')->find($fid1);
    my $feat2 = $coge->resultset('Feature')->find($fid2);
    if ($DEBUG)
      {
	print "ANNOTATIONS:\n";
	print $feat1->annotation_pretty_print."\n\n";
	print $feat2->annotation_pretty_print."\n";
	print "\n-------------------\n";
      }
    my ($source_feat, $sink_feat);
    ($source_feat, $sink_feat) = ($feat1, $feat2) if $source == 1;
    ($source_feat, $sink_feat) = ($feat2, $feat1) if $source == 2;
    print "SOURCE FEATURE IS $source\n" if $DEBUG && $source;
    map_annotation(source=>$source_feat, sink=>$sink_feat)    if ($source_feat && $sink_feat);
    print "\n-------------------\n" if $DEBUG;

  }

close IN;

sub map_annotation
  {
    my %opts = @_;
    my $source = $opts{source}; #mapping annotations from
    my $sink = $opts{sink}; #mapping annotations to
    print "Cloning annotations from ", $source->id, " to ", $sink->id,"\n" if $GO;
    #creating source mapping annotation
    my $anno_type = $coge->resultset('AnnotationType')->find_or_create({name=>"Homology Mapping"});
    my $mapping_anno = "<span class='link' onclick=window.open('OrganismView.pl?oid=".$source->organism->id."')>".$source->organism->name."</span>";
    $mapping_anno .= " <span class='link' onclick=window.open('OrganismView.pl?dsid=".$source->dataset->id."')>"."(v".$source->dataset->version.")</span>";
    $sink->add_to_annotations({annotation=>$mapping_anno,
			       annotation_type_id=>$anno_type->id}) if $GO;
    #end source mapping annotation
#    print $mapping_anno,"\n";
    name: foreach my $name ($source->feature_names)
      {
	next if $name->name =~ /^NP/;
	next if $name->name =~ /^YP/;
	foreach my $item (@skip_names)
	  {
	    next name if $name->name =~ /^$item/;
	  }
	print "NAME: ", $name->name, "\n" if $DEBUG;# && $name =~ /_/;
        $sink->add_to_feature_names({name=>$name->name,
                                 description=>$name->description}) if $GO;
      }
    foreach my $anno ($source->annotations)
      {
	print "ANNO: ",$anno->annotation,"\n" if $DEBUG;
        $sink->add_to_annotations({annotation=>$anno->annotation,
				   annotation_type_id=>$anno->annotation_type->id}) if $GO;
      }
  }
